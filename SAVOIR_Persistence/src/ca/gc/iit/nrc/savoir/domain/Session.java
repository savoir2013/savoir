// Licensed under Apache 2.0
// Copyright 2011, National Research Council of Canada
// Property of Lakehead University

//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : SAVOIR
//  @ File Name : SAVOIR_Session.java
//  @ Date : 21/10/2008
//  @ Author : Yosri Harzallah
//
//
package ca.gc.iit.nrc.savoir.domain;

import java.util.Calendar;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.xml.bind.annotation.XmlType;

/**
 * @author harzallahy
 * 
 */
@XmlType(name = "Session")
public class Session {

	/** Session being authored, not scheduled yet **/
	public static final String PENDING = "PENDING";
	/** Session accepted and scheduled: resources reserved **/
	public static final String SCHEDULED = "SCHEDULED";
	/** Session being loaded, resources and network are being set up **/
	public static final String LOADING = "LOADING";
	/** Session in progress **/
	public static final String RUNNING = "RUNNING";
	/** Session finished: normal end **/
	public static final String FINISHED = "FINISHED";
	/** Session cancelled by the user **/
	public static final String CANCELLED = "CANCELLED";

	/** ID of the session **/
	private int sessionID;
	/** session's name **/
	private String name;
	/** Session description */
	private String description;
	/** User that created the session **/
	private User requestedBy;
	/** List of subsessions **/
	private List<Session> subSessions;
	/** Holds the scheduled start and end time of the session **/
	private TimeSlot timeSlot;
	/** Date when the session was requested **/
	private Calendar submissionDate;
	/** Requested start time **/
	private Calendar requestedStartTime;
	/** Requested end time **/
	private Calendar requestedEndTime;
	/**
	 * True if session is accepted to be held, will be replaced by a SCHEDULED
	 * status
	 **/
	private boolean accepted;
	/** A session is composed of a set of connections **/
	private List<Connection> connections;
	/** A status with a value equal to one of the possible values defined above **/
	private String status;

	/** users authorized on this session */
	private List<Participant> authorizedUsers;
	/** groups authorized on this session */
	private List<Group> authorizedGroups;
	
	/** scenario associated with this session - null for unauthored */
	private Integer scenarioId;

	public Session() {

	}

	public int getSessionID() {
		return sessionID;
	}

	public String getName() {
		return name;
	}
	
	public String getDescription() {
		return description;
	}

	public User getRequestedBy() {
		return requestedBy;
	}

	public List<Session> getSubSessions() {
		return subSessions;
	}

	public TimeSlot getTimeSlot() {
		return timeSlot;
	}

	public Calendar getSubmissionDate() {
		return submissionDate;
	}

	public Calendar getRequestedStartTime() {
		return requestedStartTime;
	}

	public Calendar getRequestedEndTime() {
		return requestedEndTime;
	}

	public boolean isAccepted() {
		return accepted;
	}
	
	public Integer getScenarioId() {
		return scenarioId;
	}
	

	public void setSessionID(int sessionID) {
		this.sessionID = sessionID;
	}

	public void setName(String name) {
		this.name = name;
	}
	
	public void setDescription(String description) {
		this.description = description;
	}

	public void setRequestedBy(User requestedBy) {
		this.requestedBy = requestedBy;
	}

	public void setSubSessions(List<Session> subSessions) {
		this.subSessions = subSessions;
	}

	public void setTimeSlot(TimeSlot timeSlot) {
		this.timeSlot = timeSlot;
	}

	public void setSubmissionDate(Calendar submissionDate) {
		this.submissionDate = submissionDate;
	}

	public void setRequestedStartTime(Calendar requestedStartTime) {
		this.requestedStartTime = requestedStartTime;
	}

	public void setRequestedEndTime(Calendar requestedEndTime) {
		this.requestedEndTime = requestedEndTime;
	}

	public void setAccepted(boolean accepted) {
		this.accepted = accepted;
	}

	public List<Connection> getConnections() {
		return connections;
	}

	public void setConnections(List<Connection> connections) {
		this.connections = connections;
	}
	
	public void setScenarioId(Integer scenarioId) {
		this.scenarioId = scenarioId;
	}

	/**
	 * This method shifts the start and end times of the session and its
	 * subsessions by the value of slideVector
	 * 
	 * @param slideVector
	 *            Time in ms
	 */
	public void slideStartTimes(long slideVector) {
		this.getRequestedStartTime().setTimeInMillis(
				getRequestedStartTime().getTimeInMillis() + slideVector);
		this.getRequestedEndTime().setTimeInMillis(
				getRequestedEndTime().getTimeInMillis() + slideVector);
		if (this.getSubSessions() != null)
			for (Session s : this.getSubSessions()) {
				s.slideStartTimes(slideVector);
			}

	}

	/**
	 * The status of a session is determined based on the status of the
	 * subsessions (if they exist).
	 * 
	 * A session is RUNNING if at least one sub-session is RUNNING. A session is
	 * LOADING if at least one sub-session is LOADING and there are no RUNNING
	 * sub-sessions. A session is SCHEDULED if at least one sub-session is
	 * SCHEDULED and there are no RUNNING or LOADING sub-sessions. A session is
	 * PENDING if at least one sub-session is PENDING and there are no LOADING,
	 * SCHEDULED or RUNINNG sub-sessions. A session is CANCELLED if all its
	 * sub-sessions are CANCELLED. A session is FINISHED if all its sub-sessions
	 * that are not FINISHED are CANCELLED.
	 * 
	 * 
	 * @return the status of the session
	 */
	public String getStatus() {
		int pending = 0;
		int scheduled = 0;
		int loading = 0;
		int finished = 0;
		int cancelled = 0;
		if (getSubSessions() != null && getSubSessions().size() != 0) {
			for (Session ss : getSubSessions()) {
				if (ss.getStatus().equals(RUNNING))
					return RUNNING;
				if (ss.getStatus().equals(PENDING)) {
					pending++;
					continue;
				}
				if (ss.getStatus().equals(SCHEDULED)) {
					scheduled++;
					continue;
				}
				if (ss.getStatus().equals(LOADING)) {
					loading++;
					continue;
				}
				if (ss.getStatus().equals(FINISHED)) {
					finished++;
					continue;
				}
				if (ss.getStatus().equals(CANCELLED)) {
					cancelled++;
					continue;
				}
			}
			if (loading > 0)
				return LOADING;
			if (scheduled > 0)
				return SCHEDULED;
			if (pending > 0)
				return PENDING;
			if (cancelled == getSubSessions().size())
				return CANCELLED;
			return FINISHED;
		} else {
			return status;
		}
	}

	public void setStatus(String status) {
		this.status = status;
	}

	// public Set<Person> getParticipants(){
	// Set<Person> result = new HashSet<Person>();
	//		
	// if(getConnections() != null && getConnections().size()> 0){
	// for(Connection c : getConnections()){
	// if(c.getSourceEndPoint() != null && c.getSourceEndPoint().getPerson() !=
	// null){
	// result.add(c.getSourceEndPoint().getPerson());
	// }
	// if(c.getTargetEndPoint() != null && c.getTargetEndPoint().getPerson() !=
	// null){
	// result.add(c.getTargetEndPoint().getPerson());
	// }
	// }
	// }
	//		
	// if(getSubSessions() != null && getSubSessions().size() > 0){
	// for(Session s : getSubSessions()){
	// result.addAll(s.getParticipants());
	// }
	// }
	//		
	// return result;
	// }

	public Set<Resource> getResources() {
		Set<Resource> result = new HashSet<Resource>();

		if (getConnections() != null && getConnections().size() > 0) {
			for (Connection c : getConnections()) {
				if (c.getSourceEndPoint() != null
						&& c.getSourceEndPoint().getResource() != null) {
					result.add(c.getSourceEndPoint().getResource());
				}
				if (c.getTargetEndPoint() != null
						&& c.getTargetEndPoint().getResource() != null) {
					result.add(c.getTargetEndPoint().getResource());
				}
			}
		}

		if (getSubSessions() != null && getSubSessions().size() > 0) {
			for (Session s : getSubSessions()) {
				result.addAll(s.getResources());
			}
		}

		return result;
	}

	public void setAuthorizedUsers(List<Participant> participants) {
		this.authorizedUsers = participants;
	}

	public List<Participant> getAuthorizedUsers() {
		return this.authorizedUsers;
	}
	
	public void setAuthorizedGroups(List<Group> groups) {
		this.authorizedGroups = groups;
	}

	public List<Group> getAuthorizedGroups() {
		return this.authorizedGroups;
	}
}
